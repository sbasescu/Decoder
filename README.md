# Decoder
This program decodes a message using the known frequency of letters in the English language. The encoded message should be saved as a text file in the same folder as the Decode and DecodeDriver classes. To run, call the DecodeDriver file and pass the name of the text file as its argument. 

Decode: 
My decode class consists of 5 methods. The method decodeMessage(Message msg) gets the encoded message for the given Message and then calls on the other methods in the decode class to decode the message for that object. It first calls the frequencyArray method with the encoded string as its parameter. This method works by by looping through the encoded string and getting the char at each element, and if that char is a letter, incrementing the count for that letter in the array. The index for each letter in the array is given by the ASCII value for that char minus 97, so the count for a is at the 0th index, b is at the 1st index, and so on. The method decodeMessage then calls copyArray, creating an identical array. Then it calls Arrays.sort(freqArr) which sorts freqArr in ascending order or the character counts. So now there are two arrays: original, which holds the count for each letter at its index (count for a is in index 0, b is in index 1, c is in index 2…), and freqArr, which holds the the sorted counts from low to high. The map method then takes freqArr (sorted) and original (unsorted) arrays and uses nested for loops to loop through the sorted array to find where the count of the unsorted array appears, and uses that index to put the corresponding char value into a new char array. For example, it starts at the first element of the sorted array, which holds the lowest count of any char, and finds what index that count appears in the original array. It then uses the ASCII value to cast that index back into a char (index + 97), and sets the last element of the mapped array to the corresponding char. So char mapped [ ] will contain an array of chars ordered from high to low in terms of the frequency that they appear in the encoded message. I felt that it was easier just to build the mapped array from back to front instead of creating a whole other method to simply reverse the order of the freqArr because that would involve another for loop and would be unnecessary. To avoid duplicates of letters, once the unsorted[j] is mapped, I set the count of that index to -1, so the next time unsorted is looped through, it passes over that count and finds the next instance in unsorted that the count appears. I also set j = unsorted.length so the program breaks out of the first loop and goes to the next count in the sorted array. The last thing that the decodeMessage method does is set the decoded string (returned by the makeString method) for the message object. The makeString method works by simply taking in the encoded message and the mapped array as its parameters, looping through the encoded string char by char. If that char is a letter, it finds where in the mapped array the letter appears, and adds the letter that it maps to a string. For example, if the char is found to equal mapped[0], that means that it appears in the encoded message with the highest frequency, so it uses the sortedAlph string which is simply a string of letters in the alphabet ordered by their standard frequency in the English language, to add the most frequent letter in English (‘e’) to the decoded string. If the char is not a letter, then it does not need to be mapped, so it gets added to the string as it is. 


Decode Driver: 
The Decode Driver class has just the main method, which loops through the command line arguments and creates an array of Message objects with their corresponding encoded messages. Then it goes through the array of Message objects and calls the decodeMessage method in the Decode class for each Message. It then prints out the the encoded message set by the call to decodeMessage, and creates a new text file for each Message object that contains the Message’s decoded string.
